1. 为了安全
2. 仅限于浏览器
3. 基于同源策略
4. 跨域可以使用 cors,反向代理
5. cors: 后端在响应头中配置 Access-Control-Allow-\* 头
6. 分为简单请求(不触发预检请求)和复杂请求(触发预检请求)
7. 预检请求: 浏览器会自动向服务端发送一个 OPTIONS 请求，通过服务端返回的 Access-Control-Allow-\* 判定请求是否被允许
8. 简单请求支持的请求方法 head,get,post
9. 简单请求支持的请求头 Accept,Accept-Language,Content-Language,Content-Type: 只支持
   application/x-www-form-urlencoded、multipart/form-data text/plain
10. 四个头
    Access-Control-Allow-Origin,
    Access-Control-Allow-Credentials,
    Access-Control-Allow-Methods,
    Access-Control-Allow-Headers
11. 反向代理,在页面同域下配置一套反向代理服务器,页面请求同源的服务器,服务器请求上游的实际服务器,再把结果转发给前端
12. JSONP 浏览器加载 JavaScript 资源时,不受跨域的限制
13. (1)全局注册一个函数 window.getData = (data) => console.log(data)
    (2)构建一个请求 url: www.baidu.com?callback=getData
    (3)生成一个<script src="www.baidu.com?callback=getData">并插入文档中
    (4)服务端构造一个 JavaScript 函数调用表达式并返回，例如：getData('data')。
    (5)浏览器加载以上代码
14. postMessage
    即在两个 origin 下分别部署一套页面 A 与 B，A 页面通过 iframe 加载 B 页面并监听消息，B 页面发送消息。
15. window.name
    主要是利用 window.name 页面跳转不改变的特性实现跨域，即 iframe 加载一个跨域页面，设置 window.name，跳转到同域页面，可以通过 $('iframe').contentWindow.name 拿到跨域页面的数据。
16. document.domain
    可将相同一级域名下的子域名页面的 document.domain 设置为一级域名实现跨域。
    可将同域不同端口的 document.domain 设置为同域名实现跨域（端口被置为 null）。
17. 解决 图片跨域和监控上报错误内容只有 Script Error 时添加 crossorigin="anonymous"
