import { useState, memo } from "react";

```js
export default function App() {
  let [color, setColor] = useState("red");
  return (
    <>
      <input value={color} onChange={(e) => setColor(e.target.value)} />
      <p style={{ color }}>Hello, world!</p>
      <ExpensiveTree />
    </>
  );
}

// 费时组件
let ExpensiveTree = () => {
  let now = performance.now();
  while (performance.now() - now < 100) {
    // Artificial delay -- do nothing for 100ms
  }
  return <p>I am a very slow component tree.</p>;
};
```

1. memo

```js
let ExpensiveTree = memo(() => {
  let now = performance.now();
  while (performance.now() - now < 100) {
    // Artificial delay -- do nothing for 100ms
  }
  return <p>I am a very slow component tree.</p>;
});
```

1. 将复杂计算的内容和需要刷新的内容独立
   需要刷新的内容独立出来

```js
const Form = () => {
  let [color, setColor] = useState("red");
  return (
    <>
      <input value={color} onChange={(e) => setColor(e.target.value)} />
      <p style={{ color }}>Hello, world!</p>
    </>
  );
};

export default function App() {
  return (
    <>
      <Form />
      <ExpensiveTree />
    </>
  );
}

// 费时组件
let ExpensiveTree = () => {
  let now = performance.now();
  while (performance.now() - now < 100) {
    // Artificial delay -- do nothing for 100ms
  }
  return <p>I am a very slow component tree.</p>;
};
```

// 3. 将复杂内容作为 children 传入

```js
const Picker = ({ children }) => {
  let [color, setColor] = useState("red");
  return (
    <div color={color}>
      <input value={color} onChange={(e) => setColor(e.target.value)} />
      {children}
    </div>
  );
};

export default function App() {
  return (
    <Picker>
      <p>Hello, world!</p>
      <ExpensiveTree />
    </Picker>
  );
}

// 费时组件
let ExpensiveTree = () => {
  let now = performance.now();
  while (performance.now() - now < 100) {
    // Artificial delay -- do nothing for 100ms
  }
  return <p>I am a very slow component tree.</p>;
};
```
