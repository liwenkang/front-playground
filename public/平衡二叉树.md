```js
// 先序判断是否平衡
const inOrderIsBalanced = (root) => {
  // 如果某二叉树中任意节点的左右子树的深度相差不超过 1，那么它就是一棵平衡二叉树。

  // (1)任意节点意味着需要递归,并在递归过程中判断
  // (2)获取左右子树的深度
  // (3)递归过程中左右子树的深度相差不超过 1
  // (4)空的二叉树一定是平衡二叉树

  // 获取树的深度
  const getDepth = (root) => {
    if (!root) {
      return 0;
    } else {
      return Math.max(getDepth(root.left), getDepth(root.right)) + 1;
    }
  };

  const dfs = (root) => {
    if (!root) {
      return true; // 空的二叉树一定是平衡二叉树
    } else {
      return (
        // 递归
        getDepth(root.left) - getDepth(root.right) <= 1 && // 递归过程中左右子树的深度相差不超过 1
        inOrderIsBalanced(root.left) &&
        inOrderIsBalanced(root.right)
      );
    }
  };

  dfs(root);
};
```

```js
// 后续判断是否平衡
const postOrderIsBalanced = (root) => {
  // 默认 true
  let flag = true;

  const getMaxDepth = (root) => {
    if (!root) {
      return 0;
    }
    const leftMaxDepth = getMaxDepth(root.left);
    const rightMaxDepth = getMaxDepth(root.right);

    // 后续遍历
    if (Math.abs(leftMaxDepth - rightMaxDepth) > 1) {
      flag = false;
    }
    return Math.max(leftMaxDepth, rightMaxDepth) + 1;
  };

  getMaxDepth(root);
  return flag;
};
```
